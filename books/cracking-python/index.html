<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161612035-1"></script>
    <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'UA-161612035-1');
    </script>
    <!--Start of Tawk.to Script-->
    <!-- <script type="text/javascript">
    var Tawk_API = Tawk_API || {},
        Tawk_LoadStart = new Date();
    (function() {
        var s1 = document.createElement("script"),
            s0 = document.getElementsByTagName("script")[0];
        s1.async = true;
        s1.src = 'https://embed.tawk.to/600547c5c31c9117cb6fac40/1esaa0ni2';
        s1.charset = 'UTF-8';
        s1.setAttribute('crossorigin', '*');
        s0.parentNode.insertBefore(s1, s0);
    })();
    </script> -->
    <!--End of Tawk.to Script-->
    <title>Cracking The Tough Parts In Python</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="description" content="Python, Freelancing, Career & OpenSource">
    <meta name="keywords" content="HTML,CSS,JavaScript,Python,Java,C++,websites,software,code audits">
    <meta name="author" content="compileralchemy">
    <meta name="theme-color" content="#ffb74d" />
    <link rel="icon" href="../..//assets/COMP_ALC.png">
    <link rel="stylesheet" type="text/css" href="prototyp.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href='https://fonts.googleapis.com/css?family=Comfortaa' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Raleway:700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Special+Elite' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.0/css/bulma.min.css">
    <link href="https://emoji-css.afeld.me/emoji.css" rel="stylesheet">
    
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">

    <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js"></script>
    <script type="text/javascript" src="js/jquery.js"></script>
    <script type="text/javascript" src="js/script.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <style type="text/css">

    </style>
    <script type="text/javascript">
    (function(c, l, a, r, i, t, y) {
        c[a] = c[a] || function() {
            (c[a].q = c[a].q || []).push(arguments) };
        t = l.createElement(r);
        t.async = 1;
        t.src = "https://www.clarity.ms/tag/" + i;
        y = l.getElementsByTagName(r)[0];
        y.parentNode.insertBefore(t, y);
    })(window, document, "clarity", "script", "b2ltvgn5pp");
    </script>

    <style type="text/css">
        /* Hide scrollbar for Chrome, Safari and Opera */
        .hide_scroll::-webkit-scrollbar {
          display: none;
        }

        /* Hide scrollbar for IE, Edge and Firefox */
        .hide_scroll {
          -ms-overflow-style: none;  /* IE and Edge */
          scrollbar-width: none;  /* Firefox */
        }

        body{
            padding: 0;
            margin: 0;
        }
        .book__title{
            margin-top: 20px;
            font-size: 50px;
        }
        .book__content h1{
            font-size: 45px;
            margin-bottom: 20px;
            margin-top: 20px;

        }
        .book__content h2{
            font-size: 35px;
            margin-bottom: 20px;
            margin-top: 20px;

        }
        .book__content table{
            margin-bottom: 15px;
        }
        .book__content th{
            border-bottom: 1px solid #ddd;
        }
        .book__content h3{
            font-size: 30px;
            margin-bottom: 20px;
            margin-top: 20px;

        }
        .book__content p{
            text-align: justify;
            margin-bottom: 10px;
            font-size: 20px;
        }
        .book__content{
            margin-bottom: 50px;
        }
        .book__content img{
            border-radius: 10px;
            display:block;
            max-height: 350px;
            margin-top: 50px;
            margin-bottom: 50px;
            margin-left: auto;
            margin-right: auto;
        }
        .book__content blockquote{
            padding: 40px;
            background-color: #eee;
            border-left: 10px solid #ccc;
            margin-top: 40px;
            margin-bottom: 40px;
            page-break-inside: avoid;
        }
        .book__content pre{
            margin-top: 40px;
            margin-bottom: 40px;
        }

        .book__content li{
            list-style-type: "👉";
            padding-left: 5px;
        }
        .book__content ul{
            padding-left: 2rem;
        }
        .toc li{
            list-style-type: "";
        }

        @page {
          size: A4;
          margin: 5mm 5mm 5mm 5mm;
          padding-top: 15px;
        }



        @media print {
            div.appendix{
              page-break-after: always;
            }
            .book__content blockquote{
                page-break-inside: avoid;
            }
            .chapter{
                page-break-before: always !important;
            }
            pre {
                break-inside: avoid !important;
            }
        }


        pre {
 white-space: pre-wrap;       /* css-3 */
 white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
 white-space: -pre-wrap;      /* Opera 4-6 */
 white-space: -o-pre-wrap;    /* Opera 7 */
 word-wrap: break-word;       /* Internet Explorer 5.5+ */
 font-size: 15px;
 font-weight: bold;
}

    
div.frontcover { 
  page: cover; 
  content: url("../../assets/books/cracking-python/cover.png");
  width: 100%;
  height: 100%; 
}

@page :first {
  margin: 0;
  padding: 0;
}

#book-wrapper{
    margin: 0;
    padding: 0;
    margin-left: 10%;
    margin-right: 10%;
}

html,body{
    overflow-x: hidden;
}
    </style>

</head>

<body class="has-background-white">

   <div style="
        position: fixed; 
        bottom: 5px;
        right: 5px;
        width: -moz-fit-content;
        width: fit-content;
        z-index: 20;
        background: #fff;
        border-radius: 5px;
        padding: 5px;
        background-color: #eaffe5;
        ">
        <a 
    
        href="https://github.com/compileralchemy/compileralchemy.github.io/blob/source/data/books/cracking_tough_parts_python.md" 
        target="_blank"
        >
        edit
        </a>
        |
        <a 
        target="_blank"
        href="https://www.compileralchemy.com/assets/books/cracking_python.pdf" 
        >
        download if on mobile
        </a>
    </div>

    <div 
    id="gdpr-thing" 
    style="
        position: fixed; 
        bottom: 5px;
        left: 5px;
        width: 200px;
        z-index: 20;
        background: #fff;
        border-radius: 5px;
        padding: 5px;
        background-color: #f5ef85;
        "
    >
    By using this website, you agree to our <a href="../../#privacy-policy">privacy policy</a> [ <a id="consent-button" href="#">Ok</a> ]
</div>
<script type="text/javascript">

    window.addEventListener('load', (event) => {
        if (localStorage.getItem('gdpr-accept')==='ok'){
            document.getElementById("gdpr-thing").style.display='none';
        }

      document.getElementById("consent-button").onclick = function() {

        document.getElementById("gdpr-thing").style.display='none';
        localStorage.setItem('gdpr-accept', 'ok');
      };
    });
</script>
    <div class="frontcover">
    </div>
    <div id="book-wrapper">
        <h1 class="book__title chapter">Cracking The Tough Parts In Python</h1>
        <span style="font-size: 20px">by Abdur-Rahmaan Janhangeer</span><br><br>
        <small>build: <span class="web-scrape build-no">0.1.0</span></small>
        <br>
        <br>
        <div class="book__content">
            <ol class="toc chapter">
<li><a href="#foreword">Foreword</a></li>
<li><a href="#contributors">Contributors</a></li>
<li><a href="#decorators">Decorators</a></li>
<li><a href="#generators">Generators</a></li>
<li><a href="#bytecodes">Bytecodes</a></li>
<li><a href="#descriptors">Descriptors (Upcoming)</a></li>
<li><a href="#lambdas">Mind Twisting Lambdas (Upcoming)</a></li>
<li><a href="#merge-concurrency">Merging AsyncIO, Threads And Multiprocessing Together (Upcoming)</a></li>
</ol>

<h1 id="foreword" class="chapter">Chapter: Foreword</h1>

<p>This is a free and OpenSource book on Python. </p>
<p>The is only one criteria to chapters in this book: They must start from scratch and dive really, really deep.</p>
<p>You can </p>
<ul>
<li>[ <a href="https://www.compileralchemy.com">view compileralchemy.com</a> ] or </li>
<li>[ <a href="https://www.compileralchemy.com/books/cracking-python/">read online</a> ] or </li>
<li>[ <a href="https://github.com/compileralchemy/compileralchemy.github.io/blob/source/data/books/cracking_tough_parts_python.md">contribute to the book</a> ] or</li>
<li>[ <a href="https://www.compileralchemy.com/assets/books/cracking_python.pdf">download the book</a> ] or</li>
<li>[ <a href="https://leanpub.com/cracking-python">support by buying on leanpub</a> ]</li>
</ul>
<p>Feel free to contribute a section, propose rewrites, fix typos etc. If you have comments, mail them to <code>arj.python at gmail dot com</code>.</p>
<h1 id="contributors" class="chapter">Chapter: Contributors</h1>

<ul>
<li>Abdur-RahmaanJ: Main content</li>
</ul>
<h1 id="decorators" class="chapter">Chapter: Decorators</h1>

<p>Decorators occur prefixed by <code>@</code>. <code>@app.route</code> in the example below is a decorator.</p>
<pre><code class="language-python">@app.route('/home')
def index_page():
    pass
</code></pre>
<h2>Properties of functions</h2>
<p>In order to understand decorators fully, it&rsquo;s great to know how functions behave.</p>
<h3>1) Functions can be nested</h3>
<p>Functions can be defined within functions</p>
<pre><code class="language-python">
def calc(a, b):

    def add(a, b):
        return a + b

    return add(a, b) * 2

print(calc(2, 2))
</code></pre>
<p>Functions can be defined within functions multiple times</p>
<pre><code class="language-python">def calc(a, b):

    def add(a, b):
        return a + b

    def minus(a, b):
        return a - b

    return add(a, b) * 2

print(calc(2, 2))
# 8
</code></pre>
<p>Functions can be defined within functions at multiple levels</p>
<pre><code class="language-python">def do_this():
    def calc(a, b):
        def add(a, b):
            return a+b

        return add(a, b) * 2
    return calc(1, 3)

print(do_this())
# 8
</code></pre>
<h3>2) Functions can take functions as arguments</h3>
<p>A normal function</p>
<pre><code class="language-python">def print_these():
    print('----')
    print('....')
    print('----')
</code></pre>
<p>calling / executing it</p>
<pre><code class="language-python">print_these()
</code></pre>
<p>The symbols <code>(</code> <code>)</code> call the function</p>
<p>We can implement a fuction to execute other functions. 
It actually calls the function we pass in as argument</p>
<pre><code class="language-python">def execute(f):
    f()
</code></pre>
<p>Applying</p>
<pre><code class="language-python">def print_these():
    print('----')
    print('....')
    print('----')

execute(print_these) # same as print_these()

# ----
# ....
# ----
</code></pre>
<p>we can also retrieve values</p>
<pre><code class="language-python">def name():
    return 'moris'


def view_value(v):
    print('the value is', v())


view_value(name)

# the value is moris
</code></pre>
<h3>3) Functions can return functions</h3>
<p>Returning a fuction: here we are returning the function <code>y</code>.</p>
<pre><code class="language-python">def x():
    def y():
        print(3)
    return y
</code></pre>
<p>Calling <code>x</code> is the same as returning <code>y</code>. To get the value of y, we must add the <code>()</code> sumbols.</p>
<pre><code class="language-python">x()()
# 3
</code></pre>
<p>To avoid this (bit ugly)</p>
<pre><code class="language-python">x()()
</code></pre>
<p>We do</p>
<pre><code class="language-python">func = x()
func()
</code></pre>
<p>Example of use</p>
<pre><code class="language-python">def welcome_message():
    def first_part():
        return '------'

    def last_part():
        return '******'

    def body():
        return 'welcome to our program'

    def main():
        print(first_part())
        print(body())
        print(last_part())

    return main

w = welcome_message()

w()
</code></pre>
<p>prints out</p>
<pre><code># ------
# welcome to our program
# ******
</code></pre>
<h3>4) Functions can be reassigned names</h3>
<p>We can change function names by reassignment</p>
<pre><code class="language-python">def add(x, y):
    return x + y

addition = add

print(addition(2, 3))
# 5
</code></pre>
<p>This still works even if we delete the original function</p>
<pre><code class="language-python">def add(x, y):
    return x + y

addition = add

del add

print(addition(2, 3))
# 5
</code></pre>
<h2>Getting arguments passed</h2>
<p>Python allows us to retrieve arguments passed to a function inside the function body itself.</p>
<h3>positional</h3>
<p>we can get all arguments passed using <code>*args</code></p>
<pre><code class="language-python">def s(*args):
    return args

print(s(1, 2, 3))
print(s(1, 2))
print(s(1))

# (1, 2, 3)
# (1, 2)
# (1,)
</code></pre>
<p>but we can change <code>*args</code> to anything like <code>*canne</code>.</p>
<pre><code class="language-python">def s(*canne):
    return canne

print(s(1, 2, 3))
print(s(1, 2))
print(s(1))

# (1, 2, 3)
# (1, 2)
# (1,)
</code></pre>
<p>This can be useful in the case of</p>
<pre><code class="language-python">def add(*nums):
    return sum(nums)

print(add(1, 2, 3, 4, 5))
print(add(100, 400, 1000))

# 15
# 1500
</code></pre>
<h3>keyword</h3>
<p><code>**kwargs</code> allows us to get all keyword arguments passed</p>
<pre><code class="language-python">def s(**kwargs):
    return kwargs

print(s(name='me', age=5, country='mauritius'))

# {'name': 'me', 'age': 5, 'country': 'mauritius'}
</code></pre>
<p>As with <code>*args</code> we can change the name <code>kwarg</code> to what we like, for example <code>**keyword_arguments</code></p>
<pre><code class="language-python">def s(**keyword_arguments):
    return keyword_arguments

print(s(name='me', age=5, country='mauritius'))

# {'name': 'me', 'age': 5, 'country': 'mauritius'}
</code></pre>
<h3>Mixing args and kwargs</h3>
<p>We can use <code>*args</code> and <code>**kwargs</code> within the same function</p>
<pre><code class="language-python">def view_args(*args, **keyw_args):
    print(args)
    print(keyw_args)

view_args(1, 2, 3, name='me', town='pl')
# (1, 2, 3)
# {'name': 'me', 'town': 'pl'}
</code></pre>
<h2>In enters the skeleton</h2>
<p>Let us take this piece of code where we pass a function to another.</p>
<pre><code class="language-python">def quote(text):
    return '&lt;&lt;{}&gt;&gt;'.format(text)

def indent(text):
    return '&gt;    {}'.format(text)

print(indent(quote('abc')))

# &gt;    &lt;&lt;abc&gt;&gt;
#
# quote('abc') '&lt;&lt;abc&gt;&gt;'
# indent(quote('abc')) '&gt;    &lt;&lt;abc&gt;&gt;'
</code></pre>
<p>We can also write it  as</p>
<pre><code class="language-python">def quote(text):
    return '&lt;&lt;{}&gt;&gt;'.format(text)

def indent(q):
    def dummy(text):
        return '&gt;    {}'.format(
            q(text)
        )
    return dummy

print(
    indent(quote)('i am here')
)
# &gt;    &lt;&lt;i am here&gt;&gt;
</code></pre>
<p>It is equivalent to:</p>
<pre><code class="language-python">def indent(q):
    def dummy(text):
        return '&gt;    {}'.format(
            q(text)
        )
    return dummy

@indent
def quote(text):
    return '&lt;&lt;{}&gt;&gt;'.format(text)

print(quote('the sun is rising'))
</code></pre>
<p>Which is neater!</p>
<h2>Chaining decorators</h2>
<p>Let&rsquo;s say we want to get the following output.</p>
<pre><code># ----
# &gt;    &lt;&lt;the sun is rising&gt;&gt;
# ----
</code></pre>
<p>We just add another function</p>
<pre><code class="language-python">def enclose(f):
    def dummy(text):
        return '----\n{}\n----'.format(
            f(text)
        )
    return dummy
</code></pre>
<p>and just call</p>
<pre><code class="language-python">@enclose
</code></pre>
<pre><code class="language-python">def enclose(f):
    def dummy(text):
        return '----\n{}\n----'.format(
            f(text)
        )
    return dummy

def indent(q):
    def dummy(text):
        return '&gt;    {}'.format(
            q(text)
        )
    return dummy

@enclose
@indent
def quote(text):
    return '&lt;&lt;{}&gt;&gt;'.format(text)

print(quote('the sun is rising'))
#    &lt;&lt;the sun is rising&gt;&gt;
</code></pre>
<p>which results in</p>
<pre><code>----
&gt;    &lt;&lt;texthere&gt;&gt;
----
</code></pre>
<h2>Adding arguments to decorators</h2>
<p>We can also add arguments to decorators.</p>
<pre><code class="language-python">def awesome_f(dec_param):
    def awesome_f_decorator(f):
        # wrap here
        def awesome_f_wrapper(p):
            # dec_param f(p)
        return awesome_f_wrapper
    return awesome_f_decorator

@awesome_f('abcd')
def some_func():
    # ...
</code></pre>
<h2>Bulletproofing our decorators</h2>
<p>The above explanations need some fixing so as to be used in the real world.
First, we need to accept all arguments.</p>
<pre><code>def indent(q):
    def dummy(*args, **kwargs):
        return '&gt;    {}'.format(
            q(*args, **kwargs)
        )
    return dummy
</code></pre>
<p>Then, we need to preserve information passed.</p>
<pre><code class="language-python">from functools import wraps
# ...
def indent(q):
    @wraps(func)
    def dummy(*args, **kwargs):
        return '&gt;    {}'.format(
            q(*args, **kwargs)
        )
    return dummy
</code></pre>
<h2>Example of deveryday decorators</h2>
<p>Here are some decorators you can encounter in everyday use.</p>
<h3>@staticmethod</h3>
<p>Let&rsquo;s take a simple class</p>
<pre><code class="language-python">import math

class Calcs:

    def add(self, x, y):
        return x + y

    def hypotenuse(self, x, y):
        return math.sqrt((x**2) + (y**2))

c = Calcs()
print(c.hypotenuse(3, 4))

# 5.0
</code></pre>
<p>The functions not are not related together</p>
<p>Adding <code>@staticmethod</code>.</p>
<pre><code class="language-python">import math

class Calcs:

    @staticmethod
    def add(x, y): # self removed
        return x + y

    def hypotenuse(self, x, y):
        return math.sqrt((x**2) + (y**2))

print(Calcs.add(1, 2)) # no need of instantiation

# 3
</code></pre>
<p>Uses of <code>@staticmethod</code></p>
<ul>
<li>isolate function</li>
<li>group related functions under a name space</li>
<li>visually telling purpose of function</li>
</ul>
<h3>@classmethod</h3>
<p>syntax</p>
<pre><code class="language-python">@classmethod
def method_name(var_holding_classs, argument ...
</code></pre>
<p>Demo</p>
<pre><code class="language-python">class Person:
    country = 'MU'

    @classmethod
    def say_hi(cls, name): # access class attributes through cls.
        return 'hi ' + name + ' from ' + cls.country 

print(Person.say_hi('doe'))

# hi doe from MU
</code></pre>
<h3>@property</h3>
<p>Another way of customising getters, setters and deleters</p>
<pre><code class="language-python">class Car:
    def __init__(self):
        self._wheel = None

    @property
    def wheel(self):
        return self._wheel

    @wheel.setter
    def wheel(self, number):
        self._wheel = number

    @wheel.getter
    def wheel(self):
        return self._wheel

    @wheel.deleter
    def wheel(self):
        del self._wheel
</code></pre>
<p>Use</p>
<pre><code class="language-python">nissan = Car()
nissan.wheel = 4
print(nissan.wheel)
#4
</code></pre>
<p>but if getter changed</p>
<pre><code class="language-python">    @wheel.getter
    def wheel(self):
        return self._wheel + 1
</code></pre>
<p>and printed</p>
<pre><code class="language-python">nissan = Car()
nissan.wheel = 4
print(nissan.wheel)
</code></pre>
<p>we&rsquo;d get <code>5</code></p>
<p>Same as <code>__set__</code>, <code>__get__</code> and <code>__del__</code></p>
<h2>Yeah, they are all functions</h2>
<p><code>@property</code>, <code>@staticmethod</code>, <code>@classmethod</code> are all functions, in-built ones. can be used as <code>property()</code>, <code>staticmethod()</code> and <code>classmethod()</code>.</p>
<p>try help on them</p>
<pre><code>print(help(property))
</code></pre>
<h1 id="generators" class="chapter">Chapter: Generators</h1>

<p>In Python, generators form part of the intermediate topics. Since it differs from conventional functions, beginners have to take sometimes to wrap their head around it. This article presents materials that will be useful both for beginners and advanced programmers. It attempts to give enough to understand generators in depth but don&rsquo;t cover all use cases.</p>
<h3>Why were Python generators introduced?</h3>
<p>Before we present generators and it&rsquo;s syntax, it&rsquo;s important to know why in the first place were generators introduced. The yield keyword does not mean generators. One has to understand the concept behind. The original PEP introduced &ldquo;the concept of generators to Python, as well as a new statement used in conjunction with them, the yield statement&rdquo; [1].</p>
<p>The general use case of generators is as follows:</p>
<blockquote>
<p>When a producer function has a hard enough job that it requires maintaining state between values produced, [1]
</p>
</blockquote>
<p>And more explicitly</p>
<blockquote>
<p>provide a kind of function that can return an intermediate result (&ldquo;the next value&rdquo;) to its caller, but maintaining the function&rsquo;s local state so that the function can be resumed again right where it left off. [1]
</p>
</blockquote>
<p>So we understand that a new kind of functions was needed that:</p>
<ul>
<li>
<ol>
<li>return intermediate values</li>
</ol>
</li>
<li>
<ol>
<li>save the state of functions</li>
</ol>
</li>
</ul>
<h3>How do Python Generators differ from normal functions?</h3>
<p>Compared to normal functions, once you return from a function, you can go back to return more values. A normal function in contrast, once you return from it, there is no going back.</p>
<p>Normal function:</p>
<pre><code class="language-python">def x():
    print('abc')
    return 
    print('def') # not reached
x()

</code></pre>
<p>In the above example, <code>def</code> will not be printed as the function exited before. Let&rsquo;s examine a basic generator example:</p>
<pre><code class="language-python">def x():
  a = 0
  while 1:
    yield a

    a += 1

z = x()

print(z)
print(next(z))
print(next(z))

</code></pre>
<pre><code class="language-python">&lt;generator object x at 0x01ACB760&gt;
0
1

</code></pre>
<p>From the example above, once we called next, it returned a value. <strong>The purpose of next is to go to the next yield statement</strong>. When we called next the first time, it went to the next yield since the beginning which is when <code>a</code> was initially at 0.</p>
<p>The second call of next started executing <code>a += 1</code> and went to the beginning of the loop where it encountered a yield statement and returned <code>a</code> with the updated value.</p>
<p>By <code>a</code> being updated we see that even when the function was exited the first time, when the program went back into it, it continued on the previous state when <code>a</code> was 0. This accomplishes the two aims of being able to resume functions and saving the previous state.</p>
<p>To understand it better, here are some more names that were proposed instead of yield [1] but were eventually rejected:</p>
<ul>
<li>return 3 and continue</li>
<li>return and continue 3</li>
<li>return generating 3</li>
<li>continue return 3</li>
</ul>
<p>Guido gives a summary of generators [1]:</p>
<blockquote>
<p>In practice (how you think about them), generators are functions, but with the twist that they&rsquo;re resumable.
</p>
</blockquote>
<h3>Execution flow</h3>
<p>The following snippet gives us an idea about the execution:</p>
<pre><code class="language-python">def x():
  print('started')
  while 1:
    print('before yield')
    yield
    print('after yield')


z = x()

next(z)
print('-- 2nd call')
next(z)

</code></pre>
<pre><code class="language-python">started
before yield
-- 2nd call
after yield
before yield

</code></pre>
<p>From it we confirm that the first call to next executes everything in the function until the first yield statement. We did not return any values but used yield purely to control the flow of execution in the same sense of return.</p>
<p>Yield needs not to be in infinite loops, you can use several at once in the same function body:</p>
<pre><code class="language-python">def x():
  print('start')
  yield 
  print('after 1st yield')
  yield
  print('after 2nd yield')

z = x()
next(z)
next(z)
next(z)

</code></pre>
<pre><code class="language-python">start
after 1st yield
after 2nd yield
Traceback (most recent call last):
  File &quot;lab.py&quot;, line 11, in &lt;module&gt;
    next(z)
StopIteration

</code></pre>
<p>In case you called next more than there is yield statements, generator functions raise the <code>StopIteration</code>. In case you want to auto-handle <code>StopIteration</code> until there are no more left, use &hellip; a for loop:</p>
<pre><code class="language-python">def x():
  print('start')
  yield 
  print('after 1st yield')
  yield
  print('after 2nd yield')

z = x()
for _ in z:
  pass


</code></pre>
<p>In case you return a value, the loop variable will be equal to that value:</p>
<pre><code class="language-python">def x():
  print('start')
  yield 1
  print('after 1st yield')
  yield 2
  print('after 2nd yield')

z = x()
for _ in z:
  print(_)

</code></pre>
<pre><code class="language-python">start
1
after 1st yield
2
after 2nd yield

</code></pre>
<h3>Immediate usefulness</h3>
<p>Since we saw that we can use yield with an infinite loop, this is extremely powerful. We can break infinity in steps. Consider this:</p>
<pre><code class="language-python">def odd_till(number):
  n = 1
  while n &lt; number:
    yield n
    n += 2

for odd_num in odd_till(10):
  print(odd_num)

</code></pre>
<p>We yield one number and the function exits, the for loop calls it again. It yields one number and exits. And so on. It goes about it in micro steps. The operations completed in one cycle is is just an increment <code>n += 2</code> and a check <code>n &lt; number</code>.</p>
<hr />
<blockquote>
<p>odd_till(10) or odd_till(100000000000000000000000000000000000000000000000) don&rsquo;t not cause memory errors
</p>
</blockquote>
<h3>next and for loops</h3>
<p>Two things might puzzle you:</p>
<ul>
<li>why was next used?</li>
<li>how can a function with 2 yields work when a for loop is used with it?</li>
</ul>
<p>The answer lies in in the fact that generators implement the iterator protocols, the same one used by lists. Here is a class customised to act as a generator [7]:</p>
<pre><code class="language-python"># Using the generator pattern (an iterable)
class firstn(object):
    def __init__(self, n):
        self.n = n
        self.num = 0

    def __iter__(self):
        return self

    # Python 3 compatibility
    def __next__(self):
        return self.next()

    def next(self):
        if self.num &lt; self.n:
            cur, self.num = self.num, self.num+1
            return cur
        else:
            raise StopIteration()

sum_of_first_n = sum(firstn(1000000))

</code></pre>
<h3>Generators introduced for memory saving</h3>
<p>Consider a list comprehension:</p>
<pre><code class="language-python">sum([x*x for x in range(10)])

</code></pre>
<p>A generator expression is much, much more efficicent [2]:</p>
<pre><code class="language-python">sum(x*x for x in range(10))

</code></pre>
<p>This was the second addition in the generator story.</p>
<h3>Generators for tasks</h3>
<p>Lets modify our two functions with print</p>
<pre><code class="language-python">def odd_till(number):
  n = 1
  while n &lt; number:
    print('odd_till {} currently: {}'.format(number, n))
    yield n
    n += 2

def even_till(number):
  n = 0
  while n &lt; number:
    print('even_till {} currently: {}'.format(number, n))
    yield n
    n += 2

</code></pre>
<p>Lets have a class to run functions</p>
<pre><code class="language-python">from collections import deque

class RunFunc:
  def __init__(self):
    self._queue = deque()

  def add_func(self, func):
    self._queue.append(func)

  def run(self):
    while self._queue:
      func = self._queue.popleft()
      try:
        next(func)
        self._queue.append(func)
      except StopIteration:
        pass

</code></pre>
<p>usage</p>
<pre><code class="language-python">func_runner = RunFunc()

func_runner.add_func(odd_till(5))
func_runner.add_func(even_till(4))
func_runner.add_func(odd_till(6))
func_runner.run()

</code></pre>
<hr />
<p>output</p>
<pre><code class="language-python">odd_till 5 currently: 1
even_till 4 currently: 0
odd_till 6 currently: 1
odd_till 5 currently: 3
even_till 4 currently: 2
odd_till 6 currently: 3
odd_till 6 currently: 5

</code></pre>
<p>If we rename the same thing we get a mini task scheduler [4]</p>
<pre><code class="language-python">from collections import deque

class TaskScheduler:
  def __init__(self):
    self._queue = deque()

  def add_task(self, task):
    self._queue.append(task)

  def run(self):
    while self._queue:
      task = self._queue.popleft()
      try:
        next(task)
        self._queue.append(task)
      except StopIteration:
        pass

</code></pre>
<p>usage</p>
<pre><code class="language-python">scheduler = TaskScheduler()

scheduler.add_task(odd_till(5))
scheduler.add_task(even_till(4))
scheduler.add_task(odd_till(6))
scheduler.run()

</code></pre>
<p>Just a point of note, why do we remove a task (popleft) and readd it (append)?</p>
<pre><code class="language-python">      task = self._queue.popleft()
      try:
        next(task)
        self._queue.append(task)
      except StopIteration:
        pass

</code></pre>
<p>That&rsquo;s because if it was finished (exception raised) well and good, it will go straight to the except block. Else the .append will get executed.</p>
<p>In other words if task terminated, don&rsquo;t add it back else add it back.</p>
<h3>The send method</h3>
<p>Generators support a way of sending values to generators</p>
<pre><code class="language-python">def times2():
    while True:
        val = yield
        yield val * 2

z = times2()


next(z)
print(z.send(1))
next(z)
print(z.send(2))
next(z)
print(z.send(3))

</code></pre>
<pre><code class="language-python">2
4
6

</code></pre>
<p>This was an important addition. This passage explains why was send introduced and why it&rsquo;s important in asyncio [6]:</p>
<blockquote>
<p>Python&rsquo;s generator functions are almost coroutines &ndash; but not quite &ndash; in that they allow pausing execution to produce a value, but do not provide for values or exceptions to be passed in when execution resumes &hellip; However, if it were possible to pass values or exceptions into a generator at the point where it was suspended, a simple co-routine scheduler or trampoline function would let coroutines call each other without blocking &ndash; a tremendous boon for asynchronous applications. Such applications could then write co-routines to do non-blocking socket I/O by yielding control to an I/O scheduler until data has been sent or becomes available. Meanwhile, code that performs the I/O would simply do something like this: <code>data = (yield nonblocking_read(my_socket, nbytes))</code> in order to pause execution until the <code>nonblocking_read()</code> coroutine produced a value.
</p>
</blockquote>
<p>yield was fundamentally changed with the addition of send.</p>
<ul>
<li>
<ol>
<li>Redefine yield to be an expression, rather than a statement. The current yield statement would become a yield expression whose value is thrown away. A yield expression&rsquo;s value is None whenever the generator is resumed by a normal next() call.</li>
</ol>
</li>
<li>
<ol>
<li>Add a new send() method for generator-iterators, which resumes the generator and sends a value that becomes the result of the current yield-expression. The send() method returns the next value yielded by the generator, or raises StopIteration if the generator exits without yielding another value.</li>
</ol>
</li>
</ul>
<p>send(None) can also be used instead of the first next()</p>
<h3>Deriving send</h3>
<p>How do we derive send? A tricky question indeed. Here&rsquo;s a mini snippet showing how [4]</p>
<pre><code class="language-python">from collections import deque

class ActorScheduler:
  def __init__(self):
    self._actors = { } # Mapping of names to actors
    self._msg_queue = deque() # Message queue

  def new_actor(self, name, actor):
    '''
    Admit a newly started actor to the scheduler and give it a name
    '''
    self._msg_queue.append((actor,None))
    self._actors[name] = actor

  def send(self, name, msg):
    '''
    Send a message to a named actor
    '''
    actor = self._actors.get(name)
    if actor:
      self._msg_queue.append((actor,msg))

  def run(self):
    '''
    Run as long as there are pending messages.
    '''
    while self._msg_queue:
      actor, msg = self._msg_queue.popleft()
      try:
        actor.send(msg)
      except StopIteration:
        pass

# Example use
if __name__ == '__main__':
  def printer():
    while True:
      msg = yield
      print('Got:', msg)

  def counter(sched):
    while True:
    # Receive the current count
      n = yield
      if n == 0:
        break
      # Send to the printer task
      sched.send('printer', n)
      # Send the next count to the counter task (recursive)
      sched.send('counter', n-1)


  sched = ActorScheduler()
  # Create the initial actors
  sched.new_actor('printer', printer())
  sched.new_actor('counter', counter(sched))
  # Send an initial message to the counter to initiate
  sched.send('counter', 100)
  sched.run()

</code></pre>
<p>The above can be expanded with more areas like ready, ready to read, ready to write and writing the appropriate code to switch between the areas and &hellip; you have a concurrent app. This is the basics of an operating system [4]. Using <code>sched.send</code> allows to have a loop beyond the recursion limit of python. The recursion limit is <code>import sys; sys.getrecursionlimit()</code> usually 1000. try <code>sched.send('counter', 1001)</code>.</p>
<h3>What is yield from?</h3>
<p>Consider the following code:</p>
<pre><code class="language-python">def gen_alph():
  for a in 'abc':
    yield a

def gen_nums():
  for n in '123':
    yield n


def gen_data():
  yield from gen_alph()
  yield from gen_nums()


for _ in gen_data():
  print(_)

</code></pre>
<pre><code class="language-python">a
b
c
1
2
3

</code></pre>
<p>It behaves exactly as if the alphabet and number loops with their respective yields was inside gen_data.</p>
<p>&ldquo;yield from is to generators as calls are to functions&rdquo; as Brett Cannon puts it [8]</p>
<h3>The last part</h3>
<p>Generators have a close method, caught by a GeneratorExit exception:</p>
<pre><code class="language-python">def gen_alph():
  try:
    for a in 'abc':
      yield a
  except GeneratorExit:
      print('Generator exited')

z = gen_alph()
next(z)
z.close()

</code></pre>
<pre><code class="language-python">Generator exited

</code></pre>
<p>They also have a throw method to catch errors:</p>
<pre><code class="language-python">def gen_alph():
  try:
    for a in 'abc':
      yield a
  except GeneratorExit:
      print('Generator exited')
  except Exception:
    yield 'error occured'

z = gen_alph()
next(z)
print(z.throw(Exception))

</code></pre>
<pre><code class="language-python">error occured

</code></pre>
<h3>The limit of generators: Infinity and Beyond</h3>
<p>If you really want the best of Python generators the internet can give you
copied over and over by Python sites, see David Beazley&rsquo;s 3 parts series:</p>
<ul>
<li><a href="http://www.dabeaz.com/generators">Generator Tricks for Systems Programmers</a></li>
<li><a href="http://www.dabeaz.com/coroutines/">A Curious Course on Coroutines and Concurrency</a></li>
<li>
<p><a href="http://www.dabeaz.com/finalgenerator/">Generators: The Final Frontier</a></p>
</li>
<li>
<p>[1] https://www.python.org/dev/peps/pep-0255/</p>
</li>
<li>[2] https://www.python.org/dev/peps/pep-0289/</li>
<li>[3] https://dev.to/abdurrahmaanj/add-superpowers-to-your-python-lists-using-this-feature-24nf</li>
<li>[4] Python Cookbook, David Beazley</li>
<li>[5] https://docs.python.org/3/library/asyncio-task.html</li>
<li>[6] https://www.python.org/dev/peps/pep-0342/</li>
<li>[7] https://wiki.python.org/moin/Generators</li>
<li>[8] Brett Cannon: Python 3.3: Trust Me, It&rsquo;s Better Than Python 2.7</li>
</ul>
<h1 id="bytecodes" class="chapter">Chapter: Bytecodes</h1>

<p>Traditionally, this is how Python&rsquo;s execution ensured.
Python was an interpreter ingesting source strings and executing instructions.</p>
<pre><code>-------     ---------     ---------------
| src | --&gt; | parse | --&gt; | interpreter |
-------     ---------     ---------------
</code></pre>
<p>Since sometimes Python started making use of a Virtual Machine (VM)</p>
<pre><code>------- 
| src |
-------
   |
   v
------------
| compiler |
------------
   |
   V
-------------------
| virtual machine |
-------------------

</code></pre>
<p>Though it might sound complicated, a Virtual Machine is just a program.</p>
<p>This is how typically compilation occurs.</p>
<pre><code>[ parse tree]
   ↓
[ ast ]
   ↓
[ bytecode generation ]
   ↓
[ bytecode optimisation ]
   ↓
[ flow control graph ]
   ↓
[ code object generation ]
</code></pre>
<h2>Hands-on Bytecode</h2>
<p>To execute a Python file, we feed the file name ending in <code>.py</code> to the Python interpreter.</p>
<pre><code>$ python3.10 main.py
</code></pre>
<p>We have the same result if we feen in a <code>.pyc</code> file.</p>
<pre><code>$ python3.10 __pycache__/main.cpython-310.pyc
</code></pre>
<blockquote>
<p>If the bytecodes are not being generated, we can use <code>-m compileall</code>.It is also used for creating cached bytecode files when installing libraries</p>
</blockquote>
<p>The rough steps to view the bytecode instructions from <code>.pyc</code> files is to read the files in binary mode, transform it into a code obhects then disassemble it using <code>dis.dis</code>.</p>
<pre><code class="language-python">import marshal
import sys
import dis 

header_size = 8
if sys.version_info &gt;= (3, 6):
    header_size = 12
if sys.version_info &gt;= (3, 7):
    header_size = 16
with open(&quot;__pycache__/main.cpython-310.pyc&quot;, &quot;rb&quot;) as f:
    metadata = f.read(header_size)  
    code_obj = marshal.load(f)
    dis.dis(code_obj)
</code></pre>
<p>We then have this output</p>
<pre><code>  1           0 LOAD_CONST               0 (1)
              2 STORE_NAME               0 (x)

  2           4 LOAD_CONST               1 (2)
...
</code></pre>
<p>Python provides the <code>compile()</code> function in-built.</p>
<pre><code>&gt;&gt;&gt; help(compile)
Help on built-in function compile in module builtins:

compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1, *, _feature_version=-1)
    Compile source into a code object that can be executed by exec() or eval().

    The source code may represent a Python module, statement or expression.
    The filename will be used for run-time error messages.
    The mode must be 'exec' to compile a module, 'single' to compile a
    single (interactive) statement, or 'eval' to compile an expression.
    The flags argument, if present, controls which future statements influence
    the compilation of the code.
    The dont_inherit argument, if true, stops the compilation inheriting
    the effects of any future statements in effect in the code calling
    compile; if absent or false these statements do influence the compilation,
    in addition to any features explicitly specified.
</code></pre>
<p>We can use it to transform source codes into code objects. 
Compile also serves to show that Python indeed has a compilation step occuring.</p>
<pre><code class="language-python">src = '''
x = 1 
y = 2 

print(x+y)
'''

c = compile(src, '', &quot;exec&quot;)
exec(c)
# exec(src)
</code></pre>
<p>Here is what a code object is about</p>
<pre><code>&gt;&gt;&gt; help(c)
Help on code object:

class code(object)
 |  code(argcount, posonlyargcount, kwonlyargcount, 
 nlocals, stacksize, flags, codestring, constants, 
 names, varnames, filename, name, firstlineno, 
 linetable, freevars=(), cellvars=(), /)
 |  
 |  Create a code object.  Not for the faint of heart.
...
</code></pre>
<p>Bytecode instructions are ready to be executed using <code>exec</code>.</p>
<pre><code>&gt;&gt;&gt; help(exec)
Help on built-in function exec in module builtins:

exec(source, globals=None, locals=None, /)
    Execute the given source in the context of globals 
    and locals.

    The source may be a string representing one or more 
    Python statements
    or a code object as returned by compile().
    The globals must be a dictionary and locals can be any
    mapping,
    defaulting to the current globals and locals.
    If only globals is given, locals defaults to it.
</code></pre>
<p>Code objects have interesting attributes. 
Attributes prefixed by <code>.co_</code> are of particular interest.
The <code>.co_code</code> attribute holds the bytecode content in bytes.</p>
<pre><code>&gt;&gt;&gt; c.co_code
b'd\x00Z\x00d\x01Z\x01e\x02e\x00e
\x01\x17\x00\x83\x01\x01\x00d\x02S\x00'
&gt;&gt;&gt; type(c.co_code)  
&lt;class 'bytes'&gt;
</code></pre>
<p>Looping over it gives us the bytes in numbers.
I formatted the output so as to have 2 elements on a line.</p>
<pre><code>&gt;&gt;&gt; [c for c in c.co_code]
[
100, 0, 
90, 0, 
100, 1, 
90, 1, 
101, 2, 
101, 0, 
101, 1, 
23, 0, 
131, 1, 
1, 0, 
100, 2, 
83, 0
]
</code></pre>
<h2>Bytecodes are introduced</h2>
<p>A bytecode instruction looks like this</p>
<pre><code>LOAD_CONST 2
</code></pre>
<p><code>LOAD_CONST</code> is the opcode while <code>2</code> is the oparg.</p>
<pre><code>LOAD_CONST 2 op arg

  opcode
</code></pre>
<p><code>dis.HAVE_ARGUMENT</code> is a number. Any bytecode represented by a number above it takes argument.
<code>dis.HAVE_ARGUMENT</code> can be 30 for example. If i have a bytecode represented by 40, i know it will take arguments.</p>
<p><code>dis.opname</code> is a dictionary for translating the opcode number into a string representation.
Here is a snippet for listing opcodes number and name from a code object.</p>
<pre><code>&gt;&gt;&gt; import dis
&gt;&gt;&gt; [(dis.opname[c] if i%2==0 else c) 
        for i, c in enumerate(c.co_code)]
[
    'LOAD_CONST', 0, 
    'STORE_NAME', 0, 
    'LOAD_CONST', 1, 
    'STORE_NAME', 1, 
    'LOAD_NAME', 2, 
    'LOAD_NAME', 0, 
    'LOAD_NAME', 1, 
    'BINARY_ADD', 0, 
    'CALL_FUNCTION', 1, 
    'POP_TOP', 0, 
    'LOAD_CONST', 2, 
    'RETURN_VALUE', 0
]
</code></pre>
<h2>Dissecting bytecodes</h2>
<p>Typically, the code to be inspected is placed in a function.
Then the function is disassembled using <code>dis.dis</code>.</p>
<pre><code>&gt;&gt;&gt; def func():
...     x = 1
...     y = 1
...     print(x+y)
... 
&gt;&gt;&gt; dis.dis(func)
  2           0 LOAD_CONST               1 (1)
              2 STORE_FAST               0 (x)

  3           4 LOAD_CONST               1 (1)
              6 STORE_FAST               1 (y)

  4           8 LOAD_GLOBAL              0 (print)
             10 LOAD_FAST                0 (x)
             12 LOAD_FAST                1 (y)
             14 BINARY_ADD
             16 CALL_FUNCTION            1
             18 POP_TOP
             20 LOAD_CONST               0 (None)
             22 RETURN_VALUE
</code></pre>
<p>In the above example, <code>2</code>, <code>3</code>, <code>4</code> are line numbers.
<code>0</code>, <code>2</code>, <code>4</code>, <code>6</code> are the opcode index.
It is a number assigned to the opcode line numeber.
It is used for jumps.</p>
<p><code>.co_names</code>, <code>.co_varnames</code> and <code>.co_consts</code> hold the remaining values.</p>
<pre><code>&gt;&gt;&gt; func.__code__.co_names
('print',)
&gt;&gt;&gt; func.__code__.co_varnames
('x', 'y')
&gt;&gt;&gt; func.__code__.co_consts
(None, 1)
</code></pre>
<p>Free variables are variables used in a code block but not defined there.
It is not applied to global vars.</p>
<h2>Associated concepts</h2>
<p>When inspecting a piece of code, we return an array of frames.</p>
<pre><code>inspect.stack() -&gt; [
    FrameInfo(frame, filename, lineno,
    function, code_context, index), ...]
</code></pre>
<p>Values and results live on stacks.</p>
<p><code>BINARY_ADD</code> works by poping. two values from the stack, operates on them then places the result back.</p>
<p><code>cpython/Include/opcode.h</code> has a list of opcodes.
There are some 191.</p>
<p>Frames contain contextual info about stack and interpreter states.
They are attached to a thread.</p>
<p>Each module, function and class has a frame [2]</p>
<p>Generators switch frames, but need a data stack for each frame</p>
<p>There is a frame for each code object</p>
<p>A stack of frames possible (call stack).</p>
<p><code>RETURN_VALUE</code> instructs to pass value between frames</p>
<p>There are 2 stacks: Call and data stack.</p>
<h2>How are bytecodes executed</h2>
<p><code>cpython/Programs/python.c</code> has main (or wmain) </p>
<p>It calls <code>Py_BytesMain</code> or <code>Py_Main</code> from <code>modules/main.c</code>, both calling same thing with different args.</p>
<p>The bytecode execution itself is enclosed in a big switch statement.</p>
<pre><code>switch (opcode) {
    // ...
case TARGET(BINARY_ADD): {
            PyObject *right = POP();
            PyObject *left = TOP();
            PyObject *sum;
            /* NOTE(haypo): Please don't try to micro-optimize int+int on
               CPython using bytecode, it is simply worthless.
               See http://bugs.python.org/issue21955 and
               http://bugs.python.org/issue10044 for the discussion. In short,
               no patch shown any impact on a realistic benchmark, only a minor
               speedup on microbenchmarks. */
            if (PyUnicode_CheckExact(left) &amp;&amp;
                     PyUnicode_CheckExact(right)) {
                sum = unicode_concatenate(tstate, left, right, f, next_instr);
                /* unicode_concatenate consumed the ref to left */
            }
            else {
                sum = PyNumber_Add(left, right);
                Py_DECREF(left);
            }
            Py_DECREF(right);
            SET_TOP(sum);
            if (sum == NULL)
                goto error;
            DISPATCH();
        }
</code></pre>
<p>Bytecodes not same for all versions of Python.</p>
<h2>Working of common opcodes</h2>
<p><code>BINARY_ADD</code> retrieves values from the stack, operates on them then places the result back.</p>
<pre><code>BINARY_ADD

[1, 2]
 ⬇️
[]
 ⬇️
[3]
</code></pre>
<pre><code>LOAD_CONST

[]
 ⬇️
[5]
</code></pre>
<pre><code>STORE_FAST

[5]
 ⬇️
[]
</code></pre>
<h3>Assignment</h3>
<pre><code class="language-python">x = 1
</code></pre>
<pre><code>
    1           0 LOAD_CONST               1 (1)
                2 STORE_FAST               0 (x)
</code></pre>
<h3>Conditionals</h3>
<pre><code class="language-python">if x &lt; 2:
    return True
</code></pre>
<pre><code>

  2           0 LOAD_CONST               1 (1)
              2 LOAD_CONST               2 (2)
              4 COMPARE_OP               0 (&lt;)
              6 POP_JUMP_IF_FALSE        6 (to 12)

  3           8 LOAD_CONST               3 (True)
             10 RETURN_VALUE

  2     &gt;&gt;   12 LOAD_CONST               0 (None)
             14 RETURN_VALUE

</code></pre>
<h3>While loops</h3>
<pre><code>x = 10
while x &lt; 20:
        x += 2
</code></pre>
<pre><code>  2           0 LOAD_CONST               1 (10)
              2 STORE_FAST               0 (x)

  3           4 LOAD_FAST                0 (x)
              6 LOAD_CONST               2 (20)
              8 COMPARE_OP               0 (&lt;)
             10 POP_JUMP_IF_FALSE       16 (to 32)

  4     &gt;&gt;   12 LOAD_FAST                0 (x)
             14 LOAD_CONST               3 (2)
             16 INPLACE_ADD
             18 STORE_FAST               0 (x)

  3          20 LOAD_FAST                0 (x)
             22 LOAD_CONST               2 (20)
             24 COMPARE_OP               0 (&lt;)
             26 POP_JUMP_IF_TRUE         6 (to 12)
             28 LOAD_CONST               0 (None)
             30 RETURN_VALUE
        &gt;&gt;   32 LOAD_CONST               0 (None)
             34 RETURN_VALUE
</code></pre>
<h2>The Question of Platform</h2>
<p>The VM is not a platform</p>
<p>Compiled codes may break for the next version as the developers reserve the right to change
opcode operations.</p>
<p>Currently</p>
<pre><code>
Python VM
[ stuffs ] -&gt; [ bytecode ] -&gt; [ optimised bytecodes ]

SQLite VM
[ stuffs ] -&gt; [ optimise ] -&gt; [ bytecode ]
</code></pre>
<p>Since optimisations are done after the bytecode has been fed, this opens the door for the VM to be used as a platform.
Maybe in the future we can have people writing bytecodes and targetting the VM.
Think Kotlin/Java.</p>
<h3>Dissy: A TUI disaasmbler</h3>
<p>Dissy allows us </p>
<pre><code class="language-python">src = '''
def duck():
    x = 1
'''

c = compile(src, '', &quot;exec&quot;)

import dissy
dissy.dis(c)
</code></pre>
<pre><code>python -m pip install dissy click distorm3
</code></pre>
<p><img alt="" src="https://www.compileralchemy.com/assets/books/cracking-python/dissy.png" /></p>
<h3>Interesting Bits</h3>
<p>1) Quote from a C file.</p>
<blockquote>
<p>Function objects and code objects should not be confused with each other:</p>
<p>Function objects are created by the execution of the &lsquo;def&rsquo; statement.
They reference a code object in their <code>__code__</code> attribute, which is a
purely syntactic object, i.e. nothing more than a compiled version of some
source code lines.  There is one code object per source code &ldquo;fragment&rdquo;,
but each code object can be referenced by zero or many function objects
depending only on how many times the &lsquo;def&rsquo; statement in the source was
executed so far. [4]</p>
</blockquote>
<p>2) PEP617 - Python3.9 uses a PEG-based parser (PEG - 2004)</p>
<p>Though the parser was top-down, it does not respect the rules of top-down and 
workarounds were used.
Also, the Intermediate Represetation (parse tree or Concrete Syntax Tree) was around just for the sake of it.</p>
<h2>Refs</h2>
<ul>
<li>[1] Inside The Python VM, Obi Ike-Nwosu</li>
<li>[2] A Python Interpreter Written in Python, Allison Kaptur, Ned Batchelder</li>
<li>[3] Understanding Python Bytecode, Reza Bagheri https://www.linkedin.com/in/reza-bagheri-71882a76/</li>
<li>[4] https://github.com/python/cpython/blob/3db0a21f731cec28a89f7495a82ee2670bce75fe/Include/cpython/funcobject.h#L25</li>
<li>[5] https://tenthousandmeters.com/blog</li>
</ul>
        </div>
    </div>
    
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>

</html>
